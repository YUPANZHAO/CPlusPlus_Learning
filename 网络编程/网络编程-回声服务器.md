# 网络编程_回声服务器

## 套接字概念

Socket  中文意思是“插座”，在Linux环境下，用于表示进程间网络通信的特殊文件。本质为内核借助缓冲区形成的伪文件。

既然是文件， 那么理所当然的，我们可以使用文件描述符引用套接字。Linux系统将其封装成文件的目的是为了统一接口，使得读写套接字和读写文件的操作一致。区别是文件主要应用于持久化数据的读写，而套接字多用于网络进程间数据的传递。

在TCP/IP协议中，“IP地址+TCP或UDP端口号”唯一标识网络通讯中的一个进程。“IP地址+端口号”就对应一个socket。想要建立连接的两个进程各自有一个socket来标识，那么这两个socket组成的socket pair就唯一标识一个连接，因此可以用Socket来描述网络连接的一对一关系。

## 网络字节序

在计算机世界里，有两种字节序：

* 大端字节序 - 低地址高字节、高地址低字节
* 小端字节序 - 低地址低字节、高地址高字节

发送主机通常将发送缓冲区中的数据按内存地址从低到高的顺序发出，接受主机把从网络上接受到的字节依次保存在接受缓冲区中，也是按内存地址从低到高的顺序保存，因此，网络数据流的地址应这样规定：先发出的数据是低地址，后发出的数据是高地址。

**TCP/IP协议规定：网络数据流应采用大端字节序，即低地址高字节。**

例如端口号是`1001`，转化为二进制是`0000 0011 1110 1001`，十六进制是`0x03e9`，`0x03`属于是高字节,`0xe9`是低字节。网络数据流先发出的数据是低地址，按大端字节序，低地址存放高字节，所以先发出`0x03`，后发出`0xe9`。

因为网络字节序是大端序，所以主机字节序也得是大端序。但现实往往不这么理想，如果出现主机字节序是小端字节序的情况，那么传输的数据就会解析出错误的结果，所以为了网络程序具有可移植性，就需要在发送和接受数据时调用库函数做网络字节序和主机字节序的转换。

```cpp
#include <arpa/inet.h>

uint32_t htonl(uint32_t hostlong);
uint16_t htons(uint16_t hostshort);
uint32_t ntohl(uint32_t netlong);
uint16_t ntohs(uint16_t netshort);
```

h表示host（主机字节序），n表示network（网络字节序），l表示32位长整数，s表示16位短整数。

如果主机是小端字节序，这些函数将参数做相应大小端转换后返回，如果主机是大端字节序，这些函数不做转换，将参数原封不动返回。

```cpp
#include <stdio.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <string.h>
#include <ctype.h>
#include <arpa/inet.h>

#define SERVER_PORT 666

int main() {
    // 代表信箱
    int sock;
    // 代表标签
    struct sockaddr_in server_addr;
    // 创建一个信箱
    sock = socket(AF_INET, SOCK_STREAM, 0);    
    // 把标签清零，写上地址和端口号
    bzero(&server_addr, sizeof(server_addr));
    server_addr.sin_family = AF_INET; // 选择协议族IPV4
    server_addr.sin_addr.s_addr = htonl(INADDR_ANY); // 监听本地所有IP
    server_addr.sin_port = htons(SERVER_PORT); // 绑定端口号

    // 实现标签贴到信箱上
    bind(sock, (struct sockaddr *)&server_addr, sizeof(server_addr));
	// 把信箱挂载到传达室
    listen(sock, 128);

    printf("等待客户端的连接\n");

    int done = 1;
    while(done) {
        struct sockaddr_in client;
        int client_sock, len;
        char client_ip[64];
        char buf[256];	

        socklen_t client_addr_len;
        client_addr_len = sizeof(client);
        client_sock = accept(sock, (struct sockaddr *)&client, &client_addr_len);
		// 打印客户端IP地址和端口号
        printf("client ip: %s\tport:%d\n",
            inet_ntop(AF_INET, &client.sin_addr.s_addr, client_ip, sizeof(client_ip)),
            ntohs(client.sin_port));
		// 读取客户端发送的数据
        len = read(client_sock, buf, sizeof(buf)-1);
        buf[len] = '\0';
        printf("recive[%d]: %s\n", len, buf);

        // 转换成大写
        int i;
        for(i=0; i < len; i++) buf[i] = toupper(buf[i]);
 		// 向客户端发送数据
        len = write(client_sock, buf, len);

        printf("write finished, len=%d\n", len);
        close(client_sock);	    
    }

    return 0;
}
```

```cpp
#include <stdio.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <string.h>
#include <ctype.h>
#include <arpa/inet.h>

#define SERVER_PORT 666
#define SERVER_IP "127.0.0.1"

int main(int argc, char *argv[]) {
    
    int sockfd;
    char* message;
    struct sockaddr_in serveraddr;
    char buf[64];
    int n;

    if(argc != 2) {
        fputs("Usage: ./echo_client message\n", stderr);
        exit(1);
    }

    message = argv[1];
    
    printf("message: %s\n", message);

    sockfd = socket(AF_INET, SOCK_STREAM, 0);

    memset(&serveraddr, '\0', sizeof(struct sockaddr_in));

    serveraddr.sin_family = AF_INET;
    inet_pton(AF_INET, SERVER_IP, &serveraddr.sin_addr);    
    serveraddr.sin_port = htons(SERVER_PORT);

    connect(sockfd, (struct sockaddr *)&serveraddr, sizeof(serveraddr));

    write(sockfd, message, strlen(message));
    
    n = read(sockfd, buf, sizeof(buf)-1);

    if(n > 0) {
		buf[n] = '\0';
		printf("receive: %s\n", buf);
    }else {
		perror("error!!!\n");
    }    

    printf("finished!\n");
    close(sockfd);

    return 0;
}
```

