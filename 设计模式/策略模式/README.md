# 策略模式

> 定义一系列算法，把它们一个个封装起来，并且使它们可互相替换（变化）。该模式使得算法可独立于使用它的客户程序（稳定）而变化（扩展、子类化）。——《设计模式》GoF

策略模式是通过扩展的方式面对未来算法层面的需求变化。

## 实现方式

假设有一个税率计算的程序需要编写，当前仅支持中国、美国、日本的税率转换，而在未来可能会添加其他国家的税率转换需求。

普通情况下可能会通过`if...else if...else...`来对税率转换的国家进行判断，此做法在未来需要扩展其他国家的税率转换代码时，会改动到先前的代码，而采用策略模式即可避免这个问题。

在策略模式下，会编写一个税率计算的抽象类，通过虚方法计算税率。再对不同国家分别编写其子类，实现计算税率的虚方法。这样在扩展其他国家的税率代码时，仅需要新增加一个文件，而不必更改到先前的代码，提高代码复用性。

**代码具体实现：** [strategy.cpp](./strategy.cpp)

## 隐含的优点

在使用`if...else if...else...`进行判断的情况下，会产生不必要的代码，即可能命中了`if`语句，那么`else if`和`else`中的语句就不会被执行。这段代码仍然会被加载到内存占用代码段空间，而在策略模式下就没有这个问题。

## 要点总结

* Strategy及其子类为组件提供了一系列可重用的算法，从而可以使得类型在运行时方便地根据需要在各个算法之间进行切换。
* Strategy模式提供了用条件判断语句以外的另一种选择，消除条件判断语句，就是在解耦合。含有许多条件判断语句的代码通常都需要Strategy模式。
* 如果Strategy对象没有实例变量，那么各个上下文可以共享同一个Strategy对象，从而节省对象开销。