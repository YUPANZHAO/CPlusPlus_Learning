# 桥模式

> 将抽象部分（业务功能）与实现部分（平台实现）分离，使它们都可以独立地变化。——《设计模式》GoF

## 原理

通过将原本的继承关系转变成组合关系，再利用虚方法来调用不同的实现，从而达到抽象和实现分离的目的。（编译时装配 -> 运行时装配）

**举个例子：**

原本一个消息类，需要支持不同的平台上的基础功能（n种），而在业务上也有多种不同的功能（m种），并且业务都是基于平台实现完成的。

如果通过继承来实现，需要有个抽象类Message来作为基类，里面定义好平台和业务的接口（虚方法），由此派生出多个平台实现类，如PCMessageImp、MobelMessageImp。同时因为平台实现支撑业务实现，PCMessageImp、MobelMessageImp都需要各自派生出PCXXX、PCYYY、MobelXXX、MobelYYY。

那么最终类的数量会是 1（消息抽象类）+ n（平台实现类）+ n*m（业务类），为了实现这一点功能非常的不值得，同时多个业务的逻辑都是相同的，有着极大的代码冗余，如PCXXX和MobelXXX代码除了平台不同，逻辑上完全相同。

**解决办法：**

先将消息抽象类拆分成Message和MessageImp两个类，即将抽象和实现剥离开来。

然后MessageImp类派生出不同的平台实现类，Message派生出不同的业务类。

业务类中的平台支撑交由其父类Message中的一个MessageImp指针完成，该指针即是多态调用的体现。

由此，在运行的过程中再去组装业务类和平台类，而非在编译时就开始装配不同的类。

最终类的数量是 2（抽象类）+ n（平台实现类）+ m（业务类）。

**代码实现：** [bridge.cpp](./bridge.cpp)

## 要点总结

* Bridge模式使用"对象间的组合关系"解耦了抽象和实现之间固有的绑定关系，使得抽象和实现可以沿着各种的维度来变化。所谓抽象和实现沿着各自维度的变化，即"子类化"它们。
* Bridge模式有时候类似于多继承方案，但是多继承方案往往违背单一职责原则（即一个类只有一个变化的原因），复用性比较差。Bridge模式是比多继承方案更好的解决方法。
* Bridge模式的应用一般在"两个比较强的变化维度"，有时一个类也有多于两个的变化维度，这时可以使用Bridge的扩展模式。